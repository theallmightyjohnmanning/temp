module.exports = SpatialIndexer;

var Vec2          = require('./Vec2.js');
var QuadTree      = require('./QuadTree.js');
var Spatial       = require('./Spatial.js');
var EntityManager = require('./EntityManager.js');

/**
 * @constructor
 * @param {EntityManager} entities
 * @param {{onTick:function}} loop
 */
function SpatialIndexer(container, entities, loop)
{
  this.entities = entities;

  var _this = this;
  loop.onTick(function callUpdate(dt, time) {
    _this.update(dt, time);
  });

  this.tree = new QuadTree();
}

var FILTER = [Spatial];

/**
 * @param {Number} dt
 * @param {Number} time
 */
SpatialIndexer.prototype.update = function(dt, time)
{
  var entities = this.entities.queryComponents(FILTER);
  var tree     = this.tree;

  // Resize tree
  for (var n = 0; n < entities.length; n++) {
    this.adjustTreeSize(entities[n]);
  }

  for (var m = 0; m < entities.length; m++) {
    var entity = entities[m];
    var node = entity.spatial._node;

    var valid = node && node.validateEntity(entity);
    if (valid) continue;

    // Re-insert into the tree to get where it needs to be
    if (node)
      node.remove(entity);
    tree.insert(entity);
  }
};

/**
 * Increase tree size and force a reindex.. expensive!
 * @param {{spatial: Spatial}} entity
 */
SpatialIndexer.prototype.adjustTreeSize = function(entity)
{
  var pos  = entity.spatial.position;
  var hw   = entity.spatial.hwidth;
  var tree = this.tree;
  var pad  = Math.max(this.tree.size.x, this.tree.size.y) * 0.1;

  var adjusted = false;

  // Entity constraints
  var left   = pos.x - hw.x;
  var right  = pos.x + hw.x;
  var top    = pos.y - hw.y;
  var bottom = pos.y + hw.y;

  // tree constraints
  var tLeft = tree.position.x;
  var tRight = tree.position.x + tree.size.x;
  var tTop = tree.position.y;
  var tBottom = tree.position.y + tree.size.y;

  // Increase size + move left
  if (left < tree.position.x) {
    tree.size.x += (tLeft - left) + pad;
    tree.position.x = left - pad;
    adjusted = true;
  }

  // Increase size
  if (right > tRight) {
    tree.size.x += (right - tRight) + pad;
    adjusted = true;
  }

  // Increase size and move up
  if (top < tTop) {
    tree.size.y += (tTop - top) + pad;
    tree.position.y = top - pad;
    adjusted = true;
  }

  // Increase size
  if (bottom > tBottom) {
    tree.size.y += (bottom - tBottom) + pad;
    adjusted = true;
  }

  if (adjusted) {
    this.tree.reIndex();
  }
};


